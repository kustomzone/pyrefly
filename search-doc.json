[{"title":"Introduction","type":0,"sectionRef":"#","url":"/en/docs/","content":"","keywords":"","version":"Next"},{"title":"Benefits of Type Checking​","type":1,"pageTitle":"Introduction","url":"/en/docs/#benefits-of-type-checking","content":" Adding type annotations to your Python code and using a typechecker like Pyrefly provides several important benefits:  Catch bugs early - Identify type-related errors during development rather than at runtimeImprove code quality - Type annotations serve as living documentation, making your code more readable and self-documentingEnhance developer experience - Get better IDE support with accurate autocomplete, refactoring tools, and inline documentationSafer refactoring - Make large-scale changes with confidence, knowing the typechecker will catch incompatible type usageBetter collaboration - Types create clear contracts between different parts of your codebase, making it easier for teams to work together  ","version":"Next","tagName":"h2"},{"title":"Try Pyrefly​","type":1,"pageTitle":"Introduction","url":"/en/docs/#try-pyrefly","content":" Here's a simple example showing how Pyrefly can catch type errors:    In this example, Pyrefly flags the second call to greet() because we're passing an integer (42) where a string is expected, helping you catch this issue before your code runs. To learn more about Python typing and how to use it effectively, check out our Python Typing for Beginners page.  ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/en/docs/#next-steps","content":" Ready to get started with Pyrefly? Check out these resources:  Installation Guide - Install and set up Pyrefly for your projectIDE Integration - Use Pyrefly in your favorite editorPython Typing for Beginners - Master the basics of Python's type systemFrequently Asked Questions - Common questions about Pyrefly  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Introduction","url":"/en/docs/#configuration","content":" Once you've installed Pyrefly, you can customize its behavior:  Configuration Guide - Configure Pyrefly for your project's specific needs  ","version":"Next","tagName":"h2"},{"title":"Migrating from Other Typecheckers​","type":1,"pageTitle":"Introduction","url":"/en/docs/#migrating-from-other-typecheckers","content":" If you're currently using a different Python typechecker, we have guides to help you migrate to Pyrefly:  Migrating to Pyrefly - Transition from other typecheckers like Mypy or Pyright to Pyrefly  ","version":"Next","tagName":"h2"},{"title":"Error Kinds​","type":1,"pageTitle":"Introduction","url":"/en/docs/#error-kinds","content":" Pyrefly provides detailed explanations for all the errors it can detect:  Error Kinds - A comprehensive list of all Pyrefly errors with their explanations  ","version":"Next","tagName":"h2"},{"title":"Advanced Topics​","type":1,"pageTitle":"Introduction","url":"/en/docs/#advanced-topics","content":" As you become more familiar with Pyrefly, explore these advanced topics:  Error Suppressions - Learn how to suppress specific errors that show up in PyreflyImport Resolution - Learn how Pyrefly resolves imports in your code ","version":"Next","tagName":"h2"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Precedence in Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" The following is the order in which configuration options are selected:  CLI flagEnvironment variable override -- This is the same as PYREFLY_&lt;CLI flag name&gt;Configuration optionHard-coded default  ","version":"Next","tagName":"h2"},{"title":"Type Checking Modes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#type-checking-modes","content":" Pyrefly has two different modes it can run in when type checking your project, which correspond to different but useful ways we expect most people to interact with Pyrefly:  Project mode: attempt to load a config, falling back to Pyrefly's default config when none can be found, and type check using that one config. This involves getting theproject_includes and project_excludes from the file, expanding the patterns, and type checking on those files. Project mode is used whenever -c/--config is passed in OR when no files are provided with the CLI invocation. Per-file or Single-file mode: when given FILES... (and optionally --project-excludes) during a CLI invocation, expand the patterns and find the relevant config file for each file listed. project_includes and project_excludes are ignored from the config file, but it is used for all remaining config options.  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode and single-file checking mode (see Type Checking Modesfor more info), we may perform an upward file search to find a configuration file if one is not provided with -c/--config. We each directory from the 'start location' to the filesystem root, looking first for pyrefly.toml then pyproject.toml, in the same directory before looking at its parent.  For project checking mode, the 'start location' is current working directory. For single-file checking mode, the start location is the directory containing each file to be type checked, and we find the config for each file matched by the pattern provided. No config flag can be passed into Pyrefly in single file checking mode, since the behavior is very ambiguous (would we apply the given config to each file? should the config override all settings, or jsut some of them?, ...).  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, values, or unknown config options.  If a pyproject.toml is found, Pyrefly will use the [tool.pyrefly]section if it exists, otherwise it will assume a default config. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Configuration Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" The following section lists all recognized options that can be specified in a config file or pyproject.toml Pyrefly config section.  ","version":"Next","tagName":"h2"},{"title":"project_includes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project_includes","content":" The glob patterns used to describe which files to type check, typically understood as user-space files.  This does not specifyImport Resolution priority or the path an import should be resolved from. See search_path instead.  Type: list of filesystem glob patternsDefault: [&quot;**/*.py&quot;, &quot;**/*.pyi&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project_excludes. Ifproject_excludes should not use the default value, override it with the flag as well.When a project_includes pattern does not match any files, we will return an error.If you get an error about no matches for a directory when passing a glob as a CLI argument, try wrapping the glob in quotes to prevent eager shell glob expansion.  ","version":"Next","tagName":"h3"},{"title":"project_excludes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project_excludes","content":" The glob patterns used to describe which files to avoid type checking as way to filter files that match project_includes, but we don't want to type check.  Type: list of filesystem glob patternsDefault: [&quot;**/__pycache__/**&quot;, &quot;**/.[!/.]*&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: It is an error if no files are returned from any project_includes because they are filtered out by project_excludes entries. We differentiate between an error from a project_includes that doesn't match any files, and an error from all project_includes getting filtered by project_excludes.When passing in FILES..., we also do not consult the config file for what to use for project_excludes. If project_excludes should not use the default value, override it with a flag as well. When no FILES... are passed,project_excludes overrides the config's value.  ","version":"Next","tagName":"h3"},{"title":"search_path​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#search_path","content":" A file path describing the roots from which imports should be found and imported from (including modules in project_includes). This takes the highest precedence in import order, before typeshed and site_package_path. When a project_includestype checked file is imported by another type checked file, we check all search roots to determine how to import it.  Type: list of directories specifying the rootDefault: [&quot;.&quot;]Flag equivalent: --search-pathENV equivalent: PYREFLY_SEARCH_PATHEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: We automatically append &quot;.&quot; (the directory containing the configuration file) to the search_roots when type checking as a sensible default and last attempt at an import.Libraries should not be listed here, since they may override typeshedvalues for your whole project, and have different import semantics with respect to typing. SeeImport Resolutionfor more information about how modules are imported.  ","version":"Next","tagName":"h3"},{"title":"site_package_path​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#site_package_path","content":" A file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after search_path and typeshed.  site_package_path entries have special rules around when they can be imported, according to the typing specification. SeeSite Package Path Typing Rulesfor more information, and use_untyped_imports andignore_missing_source for details on how to configure that behavior.  Type: list of directoriesDefault: result from Environment Autoconfiguration, or[] if the Python interpreter cannot be queriedFlag equivalent: --site-package-pathENV equivalent: PYREFLY_SITE_PACKAGE_PATHEquivalent configs: none  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"python_platform​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_platform","content":" The value used with conditions based on type checking againstsys.platformvalues.  Type: stringDefault: result from Environment Autoconfiguration, or &quot;linux&quot; if the Python interpreter cannot be queriedFlag equivalent: --python-platformENV equivalent: PYREFLY_PYTHON_PLATFORMEquivalent configs: pythonPlatform in Pyright, platform in mypy  ","version":"Next","tagName":"h3"},{"title":"python_version​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_version","content":" The value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value.  Type: string of the format &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]]Default: result from Environment Autoconfiguration, or3.13.0 if the Python interpreter cannot be queriedFlag equivalent: --python-versionENV equivalent: PYREFLY_PYTHON_VERSIONEquivalent configs: pythonVersion in Pyright, python_version in mypy  ","version":"Next","tagName":"h3"},{"title":"python_interpreter​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_interpreter","content":" The Python interpreter to query when attempting to autoconfigure Python environment values (site_package_path, python_platform, python_version). See the Environment Autoconfiguration section for more information.  Type: path to executableDefault: $(which python3), then $(which python), or noneFlag equivalent: --python-interpreterENV equivalent: PYREFLY_PYTHON_INTERPRETEREquivalent configs: python_executable in mypyNotes: This executes the value present in the python_interpreter field without any checks. It could be a security risk if your python_interpreter is an arbitrary executable.  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"errors​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#errors","content":" Configure (enable and disable) the errors Pyrefly emits. true (default) tells Pyrefly to emit the error, while false tells Pyrefly to hide it.  Type: Table of error code to boolean representing enabled statusDefault: errors = {}/[errors]Flag equivalent: noneENV equivalent: noneEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking.  ","version":"Next","tagName":"h3"},{"title":"replace_imports_with_any​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#replace_imports_with_any","content":" ModuleGlobs of modules from which import errors should be ignored, and the module should be replaced with typing.Any. For example, withfrom x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any.  Type: list of regexDefault: []Flag equivalent: noneENV equivalent: noneEquivalent configs: ignore_missing_imports or follow_imports = skip in mypyNotes: errors = {import-error = false} (TOML inline table for errors) has similar behavior in Pyrefly, but ignoresall import errors instead of import errors from specific modules, and won't replace findable modules with typing.Any.  ","version":"Next","tagName":"h3"},{"title":"ignore_errors_in_generated_code​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore_errors_in_generated_code","content":" Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project_excludes. The generated code status is determined by checking if the file contents contain the substring '@generated'.  Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeENV equivalent: IGNORE_ERRORS_IN_GENERATED_CODEEquivalent configs: none  ","version":"Next","tagName":"h3"},{"title":"use_untyped_imports​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#use_untyped_imports","content":" Whether to search imports in site_package_path that do not have apy.typed file unconditionally. When this is true, we skip any checks for py.typed files, and return the first valid import we can find. SeeSite Package Path Typing Rules for more information on when a site_package_path cannot be used for typing information.  Type: boolDefault: falseFlag equivalent: noneENV equivalent: noneEquivalent configs: useLibraryCodeForTypes in Pyright, follow_untyped_imports in mypy  ","version":"Next","tagName":"h3"},{"title":"ignore_missing_source​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore_missing_source","content":" Whether to skip the check for a non-stubs package when a -stubs package is found insite_package_path. When this is true, we immediately return a -stubs package when found.  The check for a non-stubs package exists to ensure you have an importable package to use in your project. When this check returns an import error, it means we couldn't find a package, and that at runtime you may not actually be able to import the given package, even if its type stubs could be found. SeeStub Files vs Source Files for more information.  ","version":"Next","tagName":"h3"},{"title":"Configuration Details​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-details","content":" This section describes some of the configuration options, behaviors, or types in more depth, when there are details shared between multiple config options or the information is more than what can fit under a single config option description.  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" If any of python_platform, python_version, orsite_package_path are empty, we attempt to query an interpreter for the missing values. By default we query $(which python3) or $(which python) if they're available on the path, but the interpreter can be overridden with the python_interpreter config option and flag. If the interpreter does not exist, we fall back to Pyrefly's defaults for all unspecified values.  The values queried from the interpreter are:  python_platform: sys.platformpython_version: sys.version_info[:3]site_package_path: site.getsitepackages() + [site.getusersitepackages()]  ","version":"Next","tagName":"h3"},{"title":"Filesystem Globbing​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#filesystem-globbing","content":" We use a standard Unix-style glob, which allows for wildcard matching when specifying a fileset. It is similar to regex, but more restricted given the subset of allowed syntax for paths on a filesystem. We currently only allow matching files with a .py or .pyi suffix.  The globs provided are relative to the config, if one is found, or the current working directory otherwise. Absolute path globs can also be provided, though this is generally not recommended, since it may not be compatible with other systems type checking your project.  We recognize the following wildcards: *, which matches zero or more characters in a single directory component**, which matches the current and any sub directories/files in those sub directories?, which matches any one character[&lt;pattern&gt;], which matches any character or character range between the brackets (character range separated by -)[!&lt;pattern&gt;], which excludes any character or character range between the brackets and after the ![] can be used to match ?, *, [, ] literally (e.g. [?]), although these are invalid as part of a Python path.  We also support non-wildcard paths, so a relative (or absolute) path like src/ will match all Python files under src/or src/my_file.py will match src/my_file.py exactly.  Any directories matched will also have their .py and .pyi files recursively matched. src/* will match all files and directories under src/, so therefore, we will recursively match everything under src/.  Examples:  src/**/*.py: only match .py files under src/src, src/, src/*, src/**, and src/**/*: match all .py and .pyi files under `src/?.py and [A-z].py: match any file that looks like &lt;letter&gt;.pysrc/path/to/my/file.py: only match src/path/to/my/file.pysrc/**/tests, src/**/tests/, src/**/tests/**, and src/**/tests/**/*: match all .py and .pyi files in src/under a directory named tests  ","version":"Next","tagName":"h3"},{"title":"Module Globbing​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#module-globbing","content":" In some config options, we've added globbing for module paths. This is different from both path globs and regex, in the sense that we're performing a match on a Python dotted import, such as this.is.any.module. The only wildcard we recognize is *, which represents zero or more segments of a module path, unless it starts a glob, in which case it must match one or more segments. The wildcard must be surrounded by ., unless it is at the start or end of a module glob.  Examples:  this.is.a.module would be equivalent to a regex like ^this\\.is\\.a\\.module. It will only match imports that look likethis.is.a.module.this.is.*.module would become ^this\\.is(\\..+)*\\.module$. It would match: this.is.modulethis.is.a.modulethis.is.a.really.long.path.to.a.module *.my.module would be equivalent to a regex like ^.+\\.my\\.module$. It would match: this.is.my.moduleheres.my.module It will not match: my.module this.is.* would be equivalent to a regex like ^this\\.is(\\..+)*. It would match: this.is.my.modulethis.is  ","version":"Next","tagName":"h3"},{"title":"Example Configuration​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-configuration","content":" This section displays an example config showing the usage of all config options listed above to make creating your own easier, and to give you an easy place to start.  ","version":"Next","tagName":"h2"},{"title":"Default pyrefly.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#default-pyreflytoml","content":" This is a configuration with the Pyrefly defaults. If you have an interpreter installed, some of these values may be overridden.  #### configuring what to type check and where to import from project_includes = [&quot;.&quot;] project_excludes = [&quot;**/__pycache__/**&quot;, &quot;**/.[!/.]*&quot;] search_path = [&quot;.&quot;] site_package_path = [] #### configuring your python environment python_platform = &quot;linux&quot; python_version = &quot;3.13&quot; # default is null/none # python_interpreter = null #### configuring your type check settings replace_imports_with_any = [] ignore_errors_in_generated_code = false use_untyped_imports = false ignore_missing_source = false [errors]   ","version":"Next","tagName":"h3"},{"title":"Example pyrefly.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyreflytoml","content":" #### configuring what to type check and where to import from project_includes = [&quot;src&quot;] project_excludes = [&quot;**/__pycache__/**&quot;, &quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search_path = [&quot;src&quot;] site_package_path = [&quot;venv/lib/python3.12/site-packages&quot;] #### configuring your python environment python_platform = &quot;linux&quot; python_version = &quot;3.12&quot; python_interpreter = &quot;venv/bin/python3&quot; #### configuring your type check settings replace_imports_with_any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore_errors_in_generated_code = true use_untyped_imports = true ignore_missing_source = true [errors] bad-assignment = false invalid-argument = false   ","version":"Next","tagName":"h3"},{"title":"Example pyproject.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyprojecttoml","content":" ... # Pyrefly header [pyrefly] #### configuring what to type check and where to import from project_includes = [&quot;src&quot;] project_excludes = [&quot;**/__pycache__/**&quot;, &quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search_path = [&quot;src&quot;] site_package_path = [&quot;venv/lib/python3.12/site-packages&quot;] #### configuring your python environment python_platform = &quot;linux&quot; python_version = &quot;3.12&quot; python_interpreter = &quot;venv/bin/python3&quot; #### configuring your type check settings replace_imports_with_any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore_errors_in_generated_code = true use_untyped_imports = true ignore_missing_source = true [pyrefly.errors] bad-assignment = false invalid-argument = false # other non-Pyrefly configs ...  ","version":"Next","tagName":"h3"},{"title":"Error Suppressions","type":0,"sectionRef":"#","url":"/en/docs/error-suppresions/","content":"Error Suppressions INFO TO BE ADDED","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/en/docs/getting-started/","content":"Getting Started Pyrefly isn't ready just yet, but you can see our roadmap here. We will be populating this section soon!","keywords":"","version":"Next"},{"title":"Pyrefly in the IDE","type":0,"sectionRef":"#","url":"/en/docs/IDE/","content":"","keywords":"","version":"Next"},{"title":"Quick start​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#quick-start","content":" Install the Pyrefly extension from the VSCode marketplace or OpenVSXOpen a python file and the extension will activate  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#features","content":" The Pyrefly extension provides:  Inline type errors matching the Pyrefly command-lineTypes shown inline and on hoverGo-to definitionAutocomplete / intellisense  ","version":"Next","tagName":"h2"},{"title":"Customization​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#customization","content":" By default, Pyrefly should work in the IDE with no configuration necessary. But to ensure your project is set up properly, see configurations.  The following configuration options are IDE-specific:  python.pyrefly.disableLanguageServices [boolean: false]: by default, Pyrefly will provide both type errors and other language features like go-to definition, intellisense, hover, etc. Enable this option to keep type errors from Pyrefly but use VSCode's Python extension for everything else.  If the project configuration does not specify the Python interpreter, Pyrefly will use the interpreter selected in VSCode.  ","version":"Next","tagName":"h2"},{"title":"Issues?​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#issues","content":" If you experience issues with the Pyrefly extension, please create an issue on github.  ","version":"Next","tagName":"h2"},{"title":"Other Editors​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#other-editors","content":" Support for other editors is community-driven. If you would like to set this up, please contribute.  An unofficial Jetbrains extension has been developed hereFor Neovim support, see the issue here ","version":"Next","tagName":"h2"},{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly uses the following import strategy:  Try to import from each entry in search_path in the order they appear using the module finding strategy. a. NOTE: we append the config file's directory to search_path automatically when using a config file as a sensible last-resort for attempting an import.Try to import from typeshed.Try to find a stub package corresponding to the import we're trying to resolve insite_package_path. Entries earlier in the site_package_path list will be selected before those appearing later in the list. See the typing spec for more info on stub packages. If we find a -stubs package, but there's no non-stubs package, return an import error. Try to find a non-stub package corresponding to the import we're trying to resolve in site_package_path. Entries earlier in the site_package_path list will be selected before those appearing later in the list.Return an import error.  See Site Package Path Typing Rules for more information about which modules are valid imports from site_package_path, and how to override that behavior.  ","version":"Next","tagName":"h2"},{"title":"Site Package Path Typing Rules​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#site-package-path-typing-rules","content":" We respect typing rules as defined by the typing spec forstubs packages,partial stubs packages, and py.typed files. That means:  if we can find any -stubs package, we do not fall back to non-stubs packages unless any of them contain apy.typed file in their top-level containing the content partial\\n.if we can't find any -stubs packages, only accept a package's types if it contains a py.typed file. Here, we only check for the existence of the file, not for any contents.  You can control the above behavior with the following two configs:  use_untyped_imports: don't worry about looking for any py.typedfile. Check for -stubs first and fall back to non-stubs, regardless of the presence of a py.typed withpartial\\n or if the non-stubs packages contain a py.typed.ignore_missing_source: don't try to check for a backing non-stubs package when we find a -stubs pacakge. Immediately return the -stubs package when found.  ","version":"Next","tagName":"h3"},{"title":"Stub Files vs Source Files​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#stub-files-vs-source-files","content":" Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  A stub package is a second package corresponding to a regular package, with -stubsappended to its name. A -stubs package should only include stub files (.pyi), which override any .py or .pyi files in the non-stubs package. These are preferred when available, since they contain the interfaces a library exposes to developers. An example of this includes the popular library pandas, and its stub package, pandas-stubs.  When importing from a non-stubs package, Pyrefly loads typing information from imports by first searching for a relevant -stubs package, then by looking at the non-stubs package's .pyi files, then falls back to a .py file. SeeAbsolute Imports for details on when non-stubs packages are allowed to be used for types, and how you can override that behavior. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/en/docs/installation/","content":"","keywords":"","version":"Next"},{"title":"Upgrading Pyrefly​","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#upgrading-pyrefly","content":" Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.  # step 1 pyrefly check --suppress-errors   # step 2 &lt;run your formatter of choice&gt;   # step 3 pyrefly check --remove-unused-ignores   Repeat the steps above until you get a clean fomatting run and a clean type check.  This will add # pyrefly: ignore comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable. ","version":"Next","tagName":"h2"},{"title":"Error Kinds","type":0,"sectionRef":"#","url":"/en/docs/error-kinds/","content":"","keywords":"","version":"Next"},{"title":"annotation-mismatch​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#annotation-mismatch","content":" This error indicates a mismatch between multiple annotations for a single variable. This is relatively uncommon, but it can happen in if-statements:  if some_cond: x: int = 1 else: x: str = &quot;two&quot; # Inconsistent type annotations for x: str, int [annotation-mismatch]   It can be helpful to annotate the variable before branch, especially if there is a useful default value for it. For example:  x: str = &quot;default&quot; if some_cond: x = &quot;actual value&quot;   ","version":"Next","tagName":"h2"},{"title":"assert-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#assert-type","content":" An assert-type error is raised when a typing.assert_type() call fails.  This error kind should never be suppressed, since that rather defeats the point of of typing.assert_type().  ","version":"Next","tagName":"h2"},{"title":"async-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#async-error","content":" async-error is reported when attempting to await on something that is not awaitable. This may indicate that a function should have been marked async but wasn't.  def some_func() -&gt; None: ... await some_func() # Expression is not awaitable [async-error]   This will also arise if the context manager used in an async with statement has __aenter__ and __aexit__ methods that are not marked async.  The fix is to use an async function in the await. This may mean making the function async or finding an existing async function to use instead.  ","version":"Next","tagName":"h2"},{"title":"bad-argument-count​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-count","content":" This error arises when a function is called with the wrong number of arguments.  def takes_three(one: int, two: int, three: int) -&gt; complex: ... take_three(3, 2) # Expected 1 more positional argument [bad-argument-count]   Note that missing-argument will be raised if pyrefly can identify that specific arguments are missing. As such, this error is more likely to appear when too many args are supplied, rather than too few.  This example shows both kinds of errors:  from typing import Callable def apply(f: Callable[[int, int], int]) -&gt; int: return f(1) # Expected 1 more positional argument [bad-argument-count] apply() # Missing argument `f` in function `apply` [missing-argument]   ","version":"Next","tagName":"h2"},{"title":"bad-argument-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-type","content":" This error indicates that the function was called with an argument of the wrong type.  def example(x: int) -&gt; None: ... example(&quot;one&quot;) # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]   This can also happen with *args and **kwargs:  def bad_args(*args: int) -&gt; None: ... bad_args(1, &quot;two&quot;) # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]   def bad_kwargs(**kwargs: int) -&gt; None: ... bad_args(x=1, y=&quot;two&quot;) # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]   ","version":"Next","tagName":"h2"},{"title":"bad-assignment​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-assignment","content":" The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.  x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]   However, it can occur in several other situations.  Here, x is marked as Final, so assigning a new value to it is an error.  from typing import Final x: Final = 1 x = 2 # `x` is marked final [bad-assignment]   In another case, attempting to annotate an assignment to an instance attribute raises this error.  class A: x: int a = A() a.x: int = 2 # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]   ","version":"Next","tagName":"h2"},{"title":"bad-class-definition​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-class-definition","content":" This error indicates that there is something wrong with the class definition. It tends to be a bit rarer, since most issues would be tagged with other error kinds, such asannotation-mismatch or one of the function errors. inheritance has its own complexities, so it has its own error kind called invalid-inheritance.  One place you may see it is dynamic class generation:  from enum import Enum Ex = Enum(&quot;Ex&quot;, [(&quot;Red&quot;, 1), (&quot;Blue&quot;, 2), (&quot;Red&quot;, 3)]) # Duplicate field `Red` [bad-class-definition]   However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.  ","version":"Next","tagName":"h2"},{"title":"bad-function-definition​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-function-definition","content":" Like bad-class-definition, this error kind is uncommon because other error kinds are used for more specific issues. For example, argument order is enforced by the parser, so def f(x: int = 1, y: str) is a parse-error.  ","version":"Next","tagName":"h2"},{"title":"bad-keyword-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-keyword-argument","content":" Attempting to call a function with an incorrect keyword argument. e.g. f(x=1, x=2), or perhaps f(y=1) (where f has no parameter y).  ","version":"Next","tagName":"h2"},{"title":"bad-override​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-override","content":" A subclass field or method incorrectly overrides a field/method of a parent class.  ","version":"Next","tagName":"h2"},{"title":"bad-return​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-return","content":" Attempting to return a value that does not match the function's return type. Can also arise when returning values from generators.  ","version":"Next","tagName":"h2"},{"title":"bad-specialization​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-specialization","content":" Attempting to specialize a generic class with incorrect type arguments. e.g.type[int, str] is an error because type accepts only 1 type arg.  ","version":"Next","tagName":"h2"},{"title":"bad-unpacking​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-unpacking","content":" An error caused by unpacking. e.g. attempting to unpack an iterable into the wrong number of variables.  ","version":"Next","tagName":"h2"},{"title":"delete-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#delete-error","content":" Attempting to del something that cannot be deleted.  ","version":"Next","tagName":"h2"},{"title":"import-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#import-error","content":" An error related to the import machinery. e.g. failed to import a module.  ","version":"Next","tagName":"h2"},{"title":"index-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#index-error","content":" Attempting to access a container with an incorrect index. This only occurs when pyre can statically verify that the index is incorrect.  ","version":"Next","tagName":"h2"},{"title":"internal-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#internal-error","content":" Internal Pyre error.  ","version":"Next","tagName":"h2"},{"title":"invalid-annotation​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-annotation","content":" Attempting to write an annotation that is invalid for some reason.  ","version":"Next","tagName":"h2"},{"title":"invalid-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-argument","content":" Passing an argument that is invalid for reasons besides type.  ","version":"Next","tagName":"h2"},{"title":"invalid-inheritance​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-inheritance","content":" An error caused by incorrect inheritance in a class or type definition. e.g. a metaclass that is not a subclass of type.  ","version":"Next","tagName":"h2"},{"title":"invalid-literal​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-literal","content":" Attempting to use a value that is not a valid kind of Literal.  ","version":"Next","tagName":"h2"},{"title":"invalid-overload​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-overload","content":" An error caused by incorrect usage of the @overload decorator. e.g. not defining multiple variants for an overloaded function.  ","version":"Next","tagName":"h2"},{"title":"invalid-param-spec​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-param-spec","content":" An error related to ParamSpec definition or usage.  ","version":"Next","tagName":"h2"},{"title":"invalid-super-call​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-super-call","content":" Attempting to call super() in a way that is not allowed. e.g. callingsuper(Y, x) on an object x that does not match the class Y.  ","version":"Next","tagName":"h2"},{"title":"invalid-syntax​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-syntax","content":" Incorrect Python syntax, construct is not allowed in this position.  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var","content":" An error caused by incorrect usage or definition of a TypeVar.  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var-tuple​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var-tuple","content":" An error caused by incorrect usage or definition of a TypeVarTuple.  ","version":"Next","tagName":"h2"},{"title":"invalid-yield​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-yield","content":" Attempting to use yield in a way that is not allowed. e.g. yield from with something that's not an iterable.  ","version":"Next","tagName":"h2"},{"title":"match-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#match-error","content":" An error caused by a bad match statement. e.g. Writing a Foo(x, y, z) pattern when Foo only matches on (x, y).  ","version":"Next","tagName":"h2"},{"title":"missing-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-argument","content":" An error caused by calling a function without all the required arguments. Should be used when we can name the specific arguments that are missing.  ","version":"Next","tagName":"h2"},{"title":"missing-attribute​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-attribute","content":" Attempting to access an attribute that does not exist.  ","version":"Next","tagName":"h2"},{"title":"missing-module-attribute​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-module-attribute","content":" Accessing an attribute that does not exist on a module.  ","version":"Next","tagName":"h2"},{"title":"no-access​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-access","content":" The attribute exists but does not support this access pattern.  ","version":"Next","tagName":"h2"},{"title":"no-matching-overload​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-matching-overload","content":" Attempting to call an overloaded function, but none of the signatures match.  ","version":"Next","tagName":"h2"},{"title":"not-a-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-a-type","content":" Attempting to use something that isn't a type where a type is expected. This is a very general error and should be used sparingly.  ","version":"Next","tagName":"h2"},{"title":"not-callable​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-callable","content":" Attempting to call a value that is not a callable.  ","version":"Next","tagName":"h2"},{"title":"not-iterable​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-iterable","content":" Attempting to use a non-iterable value as an iterable.  ","version":"Next","tagName":"h2"},{"title":"parse-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#parse-error","content":" An error related to parsing or syntax.  ","version":"Next","tagName":"h2"},{"title":"read-only​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#read-only","content":" The attribute exists but cannot be modified.  ","version":"Next","tagName":"h2"},{"title":"reveal-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#reveal-type","content":" Raised by a call to reveal_type().  ","version":"Next","tagName":"h2"},{"title":"type-alias-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#type-alias-error","content":" An error related to type alias usage or definition.  ","version":"Next","tagName":"h2"},{"title":"typed-dict-key-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#typed-dict-key-error","content":" An error related to TypedDict keys. e.g. attempting to access a TypedDict with a key that does not exist.  ","version":"Next","tagName":"h2"},{"title":"unbound-name​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unbound-name","content":" Attempting to use a name that may be unbound or uninitialized.  ","version":"Next","tagName":"h2"},{"title":"unexpected-keyword​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unexpected-keyword","content":" An error caused by a keyword argument used in the wrong place.  ","version":"Next","tagName":"h2"},{"title":"unknown-name​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unknown-name","content":" Attempting to use a name that is not defined.  ","version":"Next","tagName":"h2"},{"title":"unsupported-operand​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported-operand","content":" Attempting to apply an operator to arguments that do not support it.  ","version":"Next","tagName":"h2"},{"title":"unsupported​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported","content":" Attempting to use a feature that is not yet supported. ","version":"Next","tagName":"h2"},{"title":"Migrating from Pyright","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-pyright/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#running-pyrefly","content":" Like pyright, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly doesn't need a config file to start checking your code. Its sensible defaults are designed to work well for most projects. However, projects with existing pyright configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Pyright Config Migration​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#pyright-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a pyright config to pyrefly.  $ pyrefly config-migration path/to/your/pyrightconfig.json   This will load your existing pyrightconfig.json and transform it into a pyrefly.toml while preserving as many options as possible. See config-migration --help for more options.  There is a significant overlap between pyright's and pyrefly's configuration options, so migration is pretty straightforward. However, it may be worth checking the generated config for errors, just in case.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#config-migration-details","content":" When it comes to listing files, pyright uses just paths, while pyrefly supports glob patterns. Thankfully, paths are a subset of glob patterns, so pyrefly can just use the paths as-is. You could consider manually simplifying the paths into glob patterns, but it's not necessary.  Pyright supports four platforms: Windows, Linux, Darwin (macOS), and All. Since pyrefly only supports Python's supported platforms, we choose to treat &quot;All&quot; as &quot;linux&quot;.  ","version":"Next","tagName":"h2"},{"title":"Silencing Errors​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#silencing-errors","content":" Like pyright, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs.  To silence an error on a specific line, add a disable comment above that line:  # pyrefly: ignore x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is similar to pyright's type check rule overrides, though of course the error codes are different! ","version":"Next","tagName":"h2"},{"title":"Migrating to Pyrefly","type":0,"sectionRef":"#","url":"/en/docs/migrating-to-pyrefly/","content":"","keywords":"","version":"Next"},{"title":"Migration Guides​","type":1,"pageTitle":"Migrating to Pyrefly","url":"/en/docs/migrating-to-pyrefly/#migration-guides","content":" Migrating from Mypy - Guide for transitioning from Mypy to PyreflyMigrating from Pyright - Guide for transitioning from Pyright to Pyrefly  Choose the appropriate guide based on your current type checker to get started with your migration to Pyrefly. ","version":"Next","tagName":"h2"},{"title":"Migrating from Mypy","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-mypy/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#running-pyrefly","content":" Like mypy, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly is designed to have sensible defaults, and you may not need to configure it at all. However, projects with existing mypy configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Mypy Config Migration​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a mypy config to pyrefly.  $ pyrefly config-migration path/to/your/mypy.ini   This will load your existing mypy.ini and transform it into a pyrefly.toml while preserving as many options as possible. See config-migration --help for more options.  We do recommend checking the resulting config for errors. While there is some overlap between mypy's config options and pyrefly's config options, it's not always possible to cleanly translate one config option to another.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-migration-details","content":" files, modules, and packages are combined into project_includes. This should work exactly the same for files and packages. Mypy doesn't recurse into modules, but pyrefly will.  Pyrefly makes an effort to transform the exclude regex into a list of filepath globs for project_excludes. This should excel on simple regexes, such as some/file.py|exclude_dir/, which becomes [&quot;**/some/file.py&quot;, &quot;**/exclude_dir/&quot;].  The ignore_missing_imports per-module config option is turned into a list of modules. For example:  [mypy-some.*.module] ignore_missing_imports = True   Becomes:  replace_imports_with_any = [&quot;some.*.module&quot;]   Pyrefly does support mypy's module name pattern syntax.  Mypy's follow_untyped_imports option is allowed to be global or per-module. The pyrefly equivalent, use_untyped_imports, is only global. If any per-module section in the mypy config has follow_untyped_imports = True, then use_untyped_imports will be true in the pyrefly config.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#silencing-errors","content":" Like mypy, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs  To silence an error on a specific line, add a disable comment above that line:  # pyrefly: ignore x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is equivalent to mypy's disable_error_code, though of course the error codes are different! ","version":"Next","tagName":"h2"},{"title":"Pyrefly Frequently Asked Questions","type":0,"sectionRef":"#","url":"/en/docs/pyrefly-faq/","content":"","keywords":"","version":"Next"},{"title":"What is Pyrefly?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-pyrefly","content":" Pyrefly is a type checker for Python powering a fast and flexible IDE experience. It's a work in progress, but showing promising results for checking large code bases, better type inference and giving instant responses in IDE.  ","version":"Next","tagName":"h3"},{"title":"How do I pronounce Pyrefly?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-pronounce-pyrefly","content":" It's pronounced PIE-ur-fly, rhyming with &quot;firefly.&quot;  ","version":"Next","tagName":"h3"},{"title":"What is the relationship to Pyre?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-the-relationship-to-pyre","content":" Pyrefly is a ground-up rebuild that doesn’t share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but our design deviates in a major way from Pyre. Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.  ","version":"Next","tagName":"h3"},{"title":"Yet another Type Checker! Why not improve the ones adopted by the community already?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#yet-another-type-checker-why-not-improve-the-ones-adopted-by-the-community-already","content":" We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we will adhere to the PEP process. Pyre was the only type checker that could scale for Meta’s needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.  We built our own engine for incremental computation and designed our type checking algorithm based on years of experience in gradual type theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.  ","version":"Next","tagName":"h3"},{"title":"Why Rust?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#why-rust","content":" We would have preferred to write Pyrefly in Python, but didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.  ","version":"Next","tagName":"h3"},{"title":"Do you plan to build an LSP?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#do-you-plan-to-build-an-lsp","content":" Yes. See our roadmap for details.  ","version":"Next","tagName":"h3"},{"title":"Where do I report bugs?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#where-do-i-report-bugs","content":" Please open an issue on our GitHub page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.  ","version":"Next","tagName":"h3"},{"title":"Can I contribute to Pyrefly?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#can-i-contribute-to-pyrefly","content":" Please see the: contributing guidelines.  ","version":"Next","tagName":"h3"},{"title":"How do I know this project won't go unmaintained after a year?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-know-this-project-wont-go-unmaintained-after-a-year","content":" Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We’re in it for the long haul. Using it is the best way to see increased investment from our leadership.  ","version":"Next","tagName":"h3"},{"title":"This is cool, I want to learn more about the technical details.​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#this-is-cool-i-want-to-learn-more-about-the-technical-details","content":" See our README.md for the high level design. We plan to add more detailed documentation along with announcements on https://engineering.fb.com  ","version":"Next","tagName":"h3"},{"title":"I don't like Python's Type System. Stop wasting your time.​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#i-dont-like-pythons-type-system-stop-wasting-your-time","content":" Tell us more - seriously we want to hear your objections to typing! We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.  Curious about something else or just want to chat about bolting types onto Python, join us on Discord. ","version":"Next","tagName":"h3"},{"title":"Python Types for Python Beginners","type":0,"sectionRef":"#","url":"/en/docs/python-typing-for-beginners/","content":"","keywords":"","version":"Next"},{"title":"1. What is a Type Hint in Python?​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#1-what-is-a-type-hint-in-python","content":" A type hint in Python is a way to indicate the expected data type of a variable, function parameter, or return value. It's a hint to other developers (and to tools like type checkers and IDEs) about what type of data should be used with a particular piece of code.  Type hints are not enforced at runtime by Python itself, but they can be used by third-party tools (like Pyrefly) to catch type-related errors before your code runs. They also serve as documentation, making it easier for others to understand how to use your code. Here's an example of a simple function with type hints:  def greet(name: str) -&gt; None: print(f&quot;Hello, {name}!&quot;)   ","version":"Next","tagName":"h2"},{"title":"2. Why Bother with Type Hints?​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#2-why-bother-with-typehints","content":" Python is a dynamically typed language, which means you can write code without declaring types. However, this can lead to bugs or ambiguity in your code.  TL;DR  Catch bugs before running the code.Improve editor autocomplete &amp; refactors.Turn your code into living documentation.    ","version":"Next","tagName":"h2"},{"title":"3. Primitive Types​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#3-primitive-types","content":" Since Python 3.9 you can use all the primitive types directly as annotations.    You can also specify a parameter as optional by using Optional type, or now with the | None syntax.    ","version":"Next","tagName":"h2"},{"title":"4. Collections​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#4-collections","content":" ","version":"Next","tagName":"h2"},{"title":"Syntax Examples​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#syntaxexamples","content":" List of numbers list[int] scores: list[int] = [98, 87, 91]Tuple of two floats tuple[float, float] point: tuple[float, float] = (3.0, 4.0)Dict of str -&gt; int dict[str, int] inventory: dict[str, int] = {&quot;apples&quot;: 5}Set of strings set[str] authors: set[str] = {&quot;Bob&quot;, &quot;Eve&quot;}  Since Python 3.9 you can subscript built‑ins directly—no need for from typing import List.  ","version":"Next","tagName":"h3"},{"title":"5. Functions​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#5-functions","content":"   Default values keep their annotation:    Variable‑length arguments:    ","version":"Next","tagName":"h2"},{"title":"5. Get Type Hint Signals Directly in Your Editor​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#5-get-type-hint-signals-directly-in-your-editor","content":" You can download the Pyrefly extension for VSCode to get type hint signals directly in your IDE.  Next, install Pyrefly and check some code:  # Fast, zero‑config pip install pyrefly pyrefly check ./my_sample.py # Check you whole project pyrefly check my_project/   Create a pyrefly.toml to configure your project for Pyrefly. Instructions here.  ","version":"Next","tagName":"h2"},{"title":"6. Next Steps​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#6-nextsteps","content":" Install the Pyrefly extension and require it in your project.Annotate one small file in your project.Fix the first few warnings—don’t chase perfection yet.Increase coverage gradually; enjoy calmer coding.  Happy hacking 🐍✨  ","version":"Next","tagName":"h2"},{"title":"Next: Learn Advanced Typing Features​","type":1,"pageTitle":"Python Types for Python Beginners","url":"/en/docs/python-typing-for-beginners/#next-learn-advanced-typing-features","content":"","version":"Next","tagName":"h3"},{"title":"Type Hints for Python Developers","type":0,"sectionRef":"#","url":"/en/docs/python-typing-5-minutes/","content":"","keywords":"","version":"Next"},{"title":"Types with Inference​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#types-with-inference","content":" Static analyzers can often infer types from your code—no annotations required. Pyrefly takes this a step further.  Python's built-in types can be used to write many simple type hints.    ","version":"Next","tagName":"h3"},{"title":"Where Inference Shines ✨​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#where-inference-shines-","content":" Constant assignments (answer = 42 -&gt; int)List/tuple/dict literals with uniform elements (names = [&quot;A&quot;, &quot;B&quot;] -&gt; list[str])Return types if parameter types are annotated:    ","version":"Next","tagName":"h3"},{"title":"When to Add Hints​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#when-to-add-hints","content":" Public APIs (library or service boundaries)Mixed collections (list[int | str])Callable signatures (decorators, callbacks)  ","version":"Next","tagName":"h3"},{"title":"Define Types Inline​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#define-types-inline","content":" ","version":"Next","tagName":"h2"},{"title":"The Basics​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#the-basics","content":" Python's built-in types can be used to write many simple type hints.    ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.    ","version":"Next","tagName":"h3"},{"title":"Advanced Types​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#advanced-types","content":" ","version":"Next","tagName":"h2"},{"title":"Composing Types​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#composing-types","content":" The real power comes from composing smaller pieces into richer shapes.  ","version":"Next","tagName":"h3"},{"title":"Unions & Optional​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#unions-optional","content":"   ","version":"Next","tagName":"h3"},{"title":"Generics​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.    ","version":"Next","tagName":"h3"},{"title":"Protocols​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#protocols","content":" Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.    ","version":"Next","tagName":"h3"},{"title":"Structural Types​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#structural-types","content":" Python also employs a structural type system, often referred to as &quot;duck typing.&quot; This concept is based on the idea that if two objects have the same shape or attributes, they can be treated as being of the same type.  ","version":"Next","tagName":"h2"},{"title":"Dataclasses​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.    ","version":"Next","tagName":"h3"},{"title":"TypedDict​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.    ","version":"Next","tagName":"h3"},{"title":"Overloads​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.    ","version":"Next","tagName":"h3"},{"title":"Typing Features, PEPS available in each Python Version​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#typing-features-peps-available-in-each-python-version","content":" Feature (click PEP for details)\tWhat it adds / looks like\tIntroduced inPEP 484 -- Core type hints &amp; typing module\tdef add(a: int, b: int) -&gt; int:\t3.5 PEP 526 -- Variable annotations\tcount: int = 0\t3.6 PEP 563 -- from __future__ import annotations (lazy eval)\tAnnotations stored as strings\t3.7 (future‑flag) PEP 544 -- Protocols (structural typing)\tclass Jsonable(Protocol): ...\t3.8 PEP 589 -- TypedDict\tclass User(TypedDict): ...\t3.8 PEP 586 -- Literal types\tdef log(level: Literal[&quot;info&quot;,&quot;warn&quot;]): ...\t3.8 PEP 591 -- Final qualifier\tTOKEN: Final[str] = &quot;...&quot;\t3.8 PEP 585 -- Built‑in generics\tlist[int], dict[str, Any]\t3.9 PEP 593 -- Annotated\tx: Annotated[int, &quot;units=px&quot;]\t3.9 PEP 604 -- Union syntax\tint | None\t3.10 PEP 612 -- ParamSpec / Concatenate\tdecorator‑safe generics\t3.10 PEP 613 -- TypeAlias qualifier\tVector: TypeAlias = list[float]\t3.10 PEP 647 -- TypeGuard for narrowing\tdef is_str(x) -&gt; TypeGuard[str]: ...\t3.10 PEP 655 -- Required / NotRequired for TypedDict\toptional vs. mandatory keys\t3.11 PEP 646 -- Variadic generics (TypeVarTuple, Unpack)\ttensor shapes, 2‑D arrays, ...\t3.11 PEP 673 -- Self type\tfluent APIs: def set(...) -&gt; Self:\t3.11 PEP 681 -- dataclass_transform helper\tlibraries like Pydantic, attrs\t3.11 PEP 695 -- Class‑level generics syntax\tclass Box[T]: ...\t3.12 PEP 649 -- New deferred‑eval algorithm (replaces PEP 563)\tbecomes the default\t3.13 PEP 698 -- @override decorator\tflag intentional overrides\t3.13 (planned)  ","version":"Next","tagName":"h2"},{"title":"Key Highlights Summary:​","type":1,"pageTitle":"Type Hints for Python Developers","url":"/en/docs/python-typing-5-minutes/#key-highlights-summary","content":" Inference: Python's static analyzers can infer types from your code, reducing the need for explicit annotations. This feature enhances code readability and helps catch bugs early.Defining Types: You can define types inline using Python's built-in types, which aids in documentation and improves IDE support.Advanced Types: The guide covers advanced concepts like composing types, using unions and optionals, generics, protocols, and structural types like dataclasses and TypedDict.Practical Examples: The guide includes examples of functions, generic classes, structural typing with protocols, and more, demonstrating how to apply these concepts in real-world scenarios. ","version":"Next","tagName":"h3"}]